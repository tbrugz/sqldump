
###############################################################################
# sqlrun config file                                                          #
# https://bitbucket.org/tbrugz/sqldump                                        #
###############################################################################

basedir=work/input/
errordir=work/output/statements-errors

#
# global 'dir' & 'loginvalidstatments' properties may be defined
#

sqlrun.dir=${basedir}
sqlrun.loginvalidstatments=${errordir}/base_statements_errors.sql
# prop 'sqlrun.commit.strategy' defines, hum, the commit strategy
# (one of: 'autocommit', 'file', 'execid', 'run', 'none' ; default: file)
sqlrun.commit.strategy=execid
# TODO: sqlrun.commit.strategy=autocommit|statement|file|execid|run|none
# TODO: 'sqlrun.commit.inverval' - for 'statement' commit strategy (default is 100?)
# TODO: sqlrun.commit.inverval=1000

# default file encoding (default is UTF-8)
#sqlrun.defaultencoding=ISO-8859-1

# tokenizer class (defaults first)
#sqlrun.sqltokenizerclass=SQLStmtScanner|SQLStmtTokenizer|StringSpliter

# only executes specified ids
#sqlrun.filterbyids=05, 10

# fail on error ? (default is true)
#sqlrun.failonerror=true|false

# use, or not, prepared statements (default is true)
#sqlrun.usepreparedstatement=true|false

# to select a different connection properties prefix
#sqlrun.connpropprefix=sqlrun.conn-x

#
# execs are processed in alphanumeric-ordered way
#
# exec suffixes are: .file, .files, .statement, .import
#

sqlrun.exec.05.statement=delete from <schema>.<table>

sqlrun.exec.10.file=${basedir}/statements1.sql
sqlrun.exec.10.loginvalidstatments=${errordir}/statements1_errors.sql

sqlrun.exec.20.file=${basedir}/statements2.sql
sqlrun.exec.20.loginvalidstatments=${errordir}/statements2_errors.sql

sqlrun.exec.55.statement=update <table> set <col> = null

sqlrun.exec.60.file=${basedir}/statements3.sql
sqlrun.exec.60.loginvalidstatments=${errordir}/statements3_errors.sql

sqlrun.exec.65.statement=insert into <table> (<cols>) values (<vals>)

sqlrun.exec.68.statement=update table_x set id_y = 0 where id_z = ?
sqlrun.exec.68.param.1=42

sqlrun.exec.70.files=TABLE_.*\\.sql
sqlrun.exec.70.dir=${basedir}
sqlrun.exec.70.loginvalidstatments=${errordir}/statements3_errors.sql
# 'split' suffix splits content by semicolon - ';' (default=true) 
sqlrun.exec.70.split=false
sqlrun.exec.70.encoding=ISO-8859-1
# may be used to escape "\'", as "''" - mysql uses it, default is false
#sqlrun.exec.70.escapebackslashedapos=false

sqlrun.exec.80.import=csv
# .inserttable or .insertsql should be defined
sqlrun.exec.80.inserttable=ins_table
sqlrun.exec.80.importfile=${basedir}/file1.csv
# output appended data as the file grows - inspired by 'tail -f'
sqlrun.exec.80.follow=true|false
# default recorddelimiter: "\r?\n" (regex)
sqlrun.exec.80.recorddelimiter=\r\n
sqlrun.exec.80.columndelimiter=;
sqlrun.exec.80.encoding=ISO-8859-1
sqlrun.exec.80.skipnlines=1
# option to set null (in prepared statement) when string is empty (default is false)
#sqlrun.exec.80.emptystringasnull=false|true

sqlrun.exec.81.import=regex
sqlrun.exec.81.pattern=(.+?) \\[(.+?)\\] "(.+?)"
# pattern flags may be defined: decimal bit mask of flag options (see Pattern.compile(regex, flags))
# 01: unix-lines ; 02: case-insensitive; 04: comments; 08: multiline; 16: literal ; 32: dotall; 64: unicode-case; 128: canon-eq
#sqlrun.exec.81.patternflags=32
sqlrun.exec.81.insertsql=insert into ins_table (col1, col2, col3) values (?, ?, ?)
# .insertsql may use positional parameters that references column in import file. ex:
# sqlrun.exec.<xx>.insertsql=insert into ins_table (col1, col2, col3) values (${2}, ${1}, ${0})
sqlrun.exec.81.importfile=${basedir}/file2.log
# .importfiles (regex) may be used instead of .importfile (.importdir must also be defined). ex:
# sqlrun.exec.81.importdir=${basedir}
# sqlrun.exec.81.importfiles=file.*\\.log
# default recorddelimiter: "\n"
# column types to be used by prepared statement (currently: only int & string)
sqlrun.exec.81.columntypes=int, string, int, ...

# batch updates may be used (defaults is false) 
#sqlrun.exec.81.batchmode=false
#sqlrun.exec.81.batchsize=1000

# url may be used instead of file
sqlrun.exec.81.importurl=http://www.example.com/example.csv
# if behind a proxy, you should set these system properties: http.proxyHost, http.proxyPort
# optional message body (POST data)
sqlrun.exec.81.urlmessagebody=name=Tim&age=45

sqlrun.exec.81.recorddelimiter=\r\n
# failover option. prop '.insertsql' may be used
# failover/regex: '.pattern' may be used ; /csv: '.columndelimiter' may be used
sqlrun.exec.81.failover.1.pattern=(.+?) \\[(.+?)\\] "(.+?)" "(.+?)"
sqlrun.exec.81.failover.1.insertsql=insert into ins_table (col1, col2, col3, col4) values (?, ?, ?, ?)
sqlrun.exec.81.failover.1.columntypes=int, string, int, string
# log or not malformed records/lines (default is true)
sqlrun.exec.81.logmalformedline=true|false

# '.query' suffix for simple queries
sqlrun.exec.83.query=select count(*) from ins_table
sqlrun.exec.83.outputstream=<stderr>
sqlrun.exec.83.dumpsyntax=FFCDataDump
# optional .queryname suffix
sqlrun.exec.83.queryname=number of records in ins_table

#----------------------

#
# connection properties are similar to sqldump
#

# Derby Embedded
#sqlrun.driverclass=org.apache.derby.jdbc.EmbeddedDriver
#sqlrun.dburl=jdbc:derby:<db-path>
#sqlrun.user=sa
#sqlrun.password=sa
